# Алгоритмы и структуры данных. Домашнее задание №4

## Выполнил студент Наседкин Дмитрий Сергеевич (группа 242)

## Письменная часть

### № 1
```
write_keys(node* root) {
    v = root
    returnFromLeftChild = False
    returnFromRightChild = False
    while True:
        # Если вернулись из правого сына
        if returnFromRightChild:
            # то поднимемся до тех пор пока не дойдем до другого поворота
            while True:
                if v == root:
                    return
                if v.parent.right == v:
                    v = v.parent
                else:
                    v = v.parent
                    returnFromRightChild = False
                    break;
            continue
        # Если вернулись из левого сына
        if returnFromLeftChild:
            print(key)
            # то нужно сходить в правого
            if v.right == null:
                returnFromRightChild = True
                continue
            else:
                v = v.right
                returnFromLeftChild = False
        while v.left != null:
            v = v.left
        returnFromLeftChild = True
}
```

### № 2

#### Подготовка и предподсчет

Первым делом, для каждой вершины ее список смежности отсортируем по номерам ребер.

Теперь посчитаем $dp[v]$ - количество путей из $v$ в $n$. Для этого просто будем рассматривать вершины в порядке топ. сорта, и формула пересчета очевидна: $dp[v] = \displaystyle\sum_{(v, u) \in E}dp[u]$. Теперь насчитаем $pref[v][i] = \displaystyle\sum_{i = 1, \ (v, u) \in E}^{d_+(v)}dp[u]$, то есть префиксные суммы по дпшкам выходящих вершин отсортированных по возрастанию по номерам ребер(преф сумму будем насчитывать через предыдущие + значение очередной дпшки, за линию).

Насчитаем теперь время:

1) $O(n + m) = O(m)$ - на топ. сорт + насчитывание дпшки и преф. сумм

2) $O(m \log m) = O(m \log C)$, так как $m \leq C + n$, значит $O(m - n) = O(m)= O(C)$

Итого $O(m \log m)$ на предподсчет.

#### Ответы на запросы

##### Пункт (a)

Пусть мы стоим в $v$ вершине (если $v$ = $n$ то мы нашли нужную длину) и текущая длина равна $L$ ($v = 1, L = 0$ в начале)

Для этого для просто по массиву преф. сумм найдем первый $i \ | \ pref[v][i] \geq k$, то есть по всем прошлым вершинам суммарно путей было меньше $k$, и если пройти через данную, то $k$-ый путь найдется, следовательно нужно $v := u$ (она $i$-ая по счету), $k := k - pref[v][i - 1]$ и $L := L + 1$. После чего начем шаг заново.

Понятно, что в худшем случае мы пройдемся по всем ребрам, то есть асимптотика равна $O(m)$.

##### Пункт (б)

Давайте искать первый $i \ | \ pref[v][i] \geq k$ не перебором $i$, а с помощью бин. поиска. Докажем, что теперь алгоритм работает за $O(\log C)$:

Очевидно, что мы запустим бин. поиск в худшем случае от всех вершин кроме $n$-ой, то есть алгоритм будет работать за $O(\log d_1 + \log d_2 + \dots + \log d_{n-1}) = O(\log \displaystyle\prod_{i = 1}^{n - 1}d_i) = O(\log C)$, где $d_i - $ степень $i$-ой вершины.

## Устная и письменная часть

### № 3

### № 4



### № 5

Пусть дан массив из $n$ элементов данного типа, тогда запустим следующую процедуру:
- Добавим в волшебную структуру все элементы, после чего сделаем запрос медианы, таким образом получим $\lceil\frac{n}{2}\rceil$ по возрастанию элемент, потратив $n$ операций.
- Разделим массив на 2 части, те что больше медианы, меньшее ее, и сама медиана(можно положить в одну из частей)
- Те, что больше медианы положим в новую волшебную структуру, после чего достанем $\lceil\frac{3n}{4}\rceil$ элемент по возрастанию.
- Добавив в эту же структуру 1-2 элемента меньших или равных медиане получим $\lceil\frac{3n}{4}\rceil - 1$ элемент по возрастанию
- Повторим процедуру до тех пор, пока не получим $\lceil\frac{n}{2}\rceil + 1$ элемент, суммарно при этом мы добавили не больше чем $\lceil\frac{n}{2}\rceil$ элементов в структуру. Такии образом получили все элементы в отсортированном порядке от $\lceil\frac{n}{2}\rceil$ до $\lceil\frac{3n}{4}\rceil$

Точно также сделаем для элементов от $\lceil\frac{n}{4}\rceil$ до $\lceil\frac{n}{2}\rceil$(для этого понадобиться создать еще одну волшебную структуру), при этом добавив также не больше чем $\lceil\frac{n}{2}\rceil$ суммарно в структуру.

Потратим еще n действий, чтобы разделить массив на 3 части: все элементы меньшие чем $\lceil\frac{n}{4}\rceil$-ый, все элементы с $\lceil\frac{n}{4}\rceil$ до $\lceil\frac{3n}{4}\rceil$, все элементы большие чем $\lceil\frac{3n}{4}\rceil$-ый. 2 часть отсортирована(половина элементов). После чего запустимся от 1 и 3 части рекурсивно.

#### Время работы алгоритма

Заметим, что каждый раз мы делим массив на 3 части, при этом запускаясь от 1 и 3, выполняя при этом $\leq 16n$(немного с запасом) операций, тогда время работы алгоритма равно: $T(n) = 2 * T(\frac{n}{4}) + 16n$

Докажем, что $T(n) \leq 100 * n$ по индукции:
- База очевидна $T(1) = 1 \leq 100$
- Переход: пусть $T(m) \leq 100 * m \;\; \forall m < n$, докажем, что $T(n) \leq 100 * n$:
$$ T(n) = 2 * T(\frac{n}{4}) + 16n $$
$$ T(n) \leq 200\lceil\frac{n}{4}\rceil + 16n \leq 50n + 200 + 16n$$
$$ T(n) \leq 66n + 200 \leq 100n,$$

последний переход верен, для любых $n \geq 6$.

Таким образом доказали, что алгоритм работает за O(n) по определению.

### № 8

#### a)

Давайте запустим сортировку пузырьком на "склееном массиве", то есть единственное различие, что если индекс $i \geq n$(0-индексация), то это будет $b[i - n]$-ный элемент, иначе же $a[i]$-ный.

Так мы используем сортировку пузырьком("бубле сорт"), то не нужно доказывать корректность, время работы, количество дополнительной памяти и ее стабильность, они будут равны $O(n^2)$, $O(1)$, и стабильна соответственно.