# Алгоритмы и структуры данных. Домашнее задание №3

## Выполнил студент ПМИ Наседкин Дмитрий Сергеевич (группа 242)

## Письменная часть

### № 1

Обозначм переменные $a_1, a_2, \dots, a_n$, тогда сумма $a_1 + a_2 + \dots + a_n = S_n$.

Давайте докажем, что $S_n \ mod \ p$ равномерно распределена, тогда из этого следует, что $p(S_n \ mod \ p = r) = \frac{1}{p}$, так как у нее всего $p$ значений. И тогда очевидно, что $p(S_n = X) \leq \frac{1}{p}$, так как любой остаток $r$ можно представить как минимум 1-им способом, а значит $p(S_n = X) \leq p(S_n \ mod \ p = X \ mod \ p) = \frac{1}{p}.$

**Док-во**: Докажем по индукции по $n$:

База $n = 1$: Следует из условия на каждую переменную, очев.

Переход: Пусть при $n$ переменных $p(S_n \ mod \ p = r) = \frac{1}{p}$ (из равномерности), тогда: $$p(S_{n + 1} \ mod \ p = r) = \displaystyle\sum_{i = 0}^{p - 1}p(S_n \ mod \ p = r - i) * p(a_{n + 1} = i) = \displaystyle\sum_{i = 0}^{p - 1}\frac{1}{p^2} = \frac{p}{p^2} = \frac{1}{p},$$ то есть равномерно распределена. 

### № 2

### № 3

Заранее оговорю, что и в пунке а и в б считаем всегда по модулю $10^9 + 7$, а $p$ - это какое нибудь нечетное число, большее размера алфавита.

**Пункт a:**

**Идея:**
Если у строки $i, j$ совпадают с точностью до циклического сдвига, то можно зафиксировать строку $i$ и рассмотреть все циклические сдвиги $j$, тогда хотя бы раз строка $i$ будет равна какому-то циклическому сдвигу $j$, то строки равны с точностью до циклического сдвига, и не равны иначе.

**Предподсчет за $O(L)$**:

Давайте для каждой строки насчитаем хеши всех ее циклических сдвигов и сохраним в хеш-таблицу(`unordered_set`). Для этого насчитаем хеш нашей строки, он будет равен $s_1 * p^{|s| - 1} + s_2 * p^{|s| - 2} + \dots + s_{|s|}$ и после постепенно будем вычислять хеш каждого циклического сдвига. Пусть вычислен хеш $hash$ циклического сдвига, если начать с $i$-ой позиции, тогда хеш циклического сдвига с $i + 1$-ой позиции будет равен $(hash - s_i * p^{|s| - 1}) * p + s_i$. Все степени $p$ можно заранее предпосчитать поэтому переход делается за $O(1)$. Тогда для строки длины $l$ хеши всех циклических сдвигов считаются за $O(l)$, а значит весь предпосчет работает за $O(L)$ по времени и так как храним все циклические сдвиги для каждой строки в виде хешей, то затраченная память тоже $O(L)$.

**Ответы на запросы за $O(1)$**:

Для ответа на запрос возьмем любой(например первый из хеш-таблицы для $i$-ой строки) хеш строки $i$, и проверим существует ли такой же хеш в хеш-таблице для $j$, так как там были все циклические сдвиги $j$, то если найдется, то ответ - "да", иначе - "нет". Запрос в хеш-таблицу делается за $O(1)$, поэтому время ответа на запрос будет такое же.

## Устная и письменная часть

### № 3

**Пункт б:**

Улучшим нашу идею, заметим, что, если строки $i, j$ совпадают с точностью до циклического сдвига, то минимальный лексикографически циклический сдвиг строк $i, j$, очевидно совпадает, а значит если уметь быстро его находить(за длину строки) и для каждой насчитать хеш только для этого сдвига, то мы решим нашу задачу. Для ответа на запросы просто будем сравнивать хеши минимальных циклических сдвигов, это очевидно $O(1)$, а предпосчет будет работать за $O(L)$, то 

### № 5

Пусть дан массив из $n$ элементов данного типа, тогда запустим следующую процедуру:
- Добавим в волшебную структуру все элементы, после чего сделаем запрос медианы, таким образом получим $\lceil\frac{n}{2}\rceil$ по возрастанию элемент, потратив $n$ операций.
- Разделим массив на 2 части, те что больше медианы, меньшее ее, и сама медиана(можно положить в одну из частей)
- Те, что больше медианы положим в новую волшебную структуру, после чего достанем $\lceil\frac{3n}{4}\rceil$ элемент по возрастанию.
- Добавив в эту же структуру 1-2 элемента меньших или равных медиане получим $\lceil\frac{3n}{4}\rceil - 1$ элемент по возрастанию
- Повторим процедуру до тех пор, пока не получим $\lceil\frac{n}{2}\rceil + 1$ элемент, суммарно при этом мы добавили не больше чем $\lceil\frac{n}{2}\rceil$ элементов в структуру. Такии образом получили все элементы в отсортированном порядке от $\lceil\frac{n}{2}\rceil$ до $\lceil\frac{3n}{4}\rceil$

Точно также сделаем для элементов от $\lceil\frac{n}{4}\rceil$ до $\lceil\frac{n}{2}\rceil$(для этого понадобиться создать еще одну волшебную структуру), при этом добавив также не больше чем $\lceil\frac{n}{2}\rceil$ суммарно в структуру.

Потратим еще n действий, чтобы разделить массив на 3 части: все элементы меньшие чем $\lceil\frac{n}{4}\rceil$-ый, все элементы с $\lceil\frac{n}{4}\rceil$ до $\lceil\frac{3n}{4}\rceil$, все элементы большие чем $\lceil\frac{3n}{4}\rceil$-ый. 2 часть отсортирована(половина элементов). После чего запустимся от 1 и 3 части рекурсивно.

#### Время работы алгоритма

Заметим, что каждый раз мы делим массив на 3 части, при этом запускаясь от 1 и 3, выполняя при этом $\leq 16n$(немного с запасом) операций, тогда время работы алгоритма равно: $T(n) = 2 * T(\frac{n}{4}) + 16n$

Докажем, что $T(n) \leq 100 * n$ по индукции:
- База очевидна $T(1) = 1 \leq 100$
- Переход: пусть $T(m) \leq 100 * m \;\; \forall m < n$, докажем, что $T(n) \leq 100 * n$:
$$ T(n) = 2 * T(\frac{n}{4}) + 16n $$
$$ T(n) \leq 200\lceil\frac{n}{4}\rceil + 16n \leq 50n + 200 + 16n$$
$$ T(n) \leq 66n + 200 \leq 100n,$$

последний переход верен, для любых $n \geq 6$.

Таким образом доказали, что алгоритм работает за O(n) по определению.

### № 8

#### a)

Давайте запустим сортировку пузырьком на "склееном массиве", то есть единственное различие, что если индекс $i \geq n$(0-индексация), то это будет $b[i - n]$-ный элемент, иначе же $a[i]$-ный.

Так мы используем сортировку пузырьком("бубле сорт"), то не нужно доказывать корректность, время работы, количество дополнительной памяти и ее стабильность, они будут равны $O(n^2)$, $O(1)$, и стабильна соответственно.